# SPI Protocol Implementation and Verification

## Overview

This repository contains a complete implementation of the **Serial Peripheral Interface (SPI) protocol** in **Verilog** along with comprehensive **SystemVerilog testbenches** for verification. The project demonstrates both design and verification of a serial communication protocol commonly used in embedded systems and microcontrollers.

## Project Description

The SPI (Serial Peripheral Interface) is a synchronous serial communication protocol that enables full-duplex data exchange between a master device and one or more slave devices. This implementation provides a modular, synthesizable design with complete verification coverage.

## Features

### SPI Master Module
- **Configurable clock divisor** for different SPI clock frequencies
- **Clock polarity (CPOL) and phase (CPHA)** support
- **Parameterized data width** support
- **Full-duplex simultaneous transmit and receive**
- **Ready/valid handshake signals**
- **State machine-based implementation**

### SPI Slave Module
- **Synchronous design** with clock and reset signals
- **Configurable mode support** (SPI Mode 0-3)
- **Data synchronization** with master clock
- **Shift register implementation** for serial-to-parallel and parallel-to-serial conversion
- **Status signals** for data availability and busy conditions

### Top-Level Integration
- **Master-Slave interconnection** module
- **Signal routing** for SCLK, MOSI, MISO, and CS signals
- **Complete SPI protocol interface**

## File Structure

```
.
├── SPI_master.v              # SPI Master RTL implementation
├── SPI_slave.v               # SPI Slave RTL implementation
├── SPI_top.v                 # Top-level module connecting master and slave
├── SPI_simple_tb.v           # Basic Verilog testbench
├── SPI_top_verification.sv   # Comprehensive SystemVerilog testbench
├── README.md
```

## SPI Protocol Basics

### Signals
- **SCLK (Serial Clock):** Clock signal generated by the master
- **MOSI (Master Out Slave In):** Data line from master to slave
- **MISO (Master In Slave Out):** Data line from slave to master
- **CS/SS (Chip Select):** Slave selection signal (active low)

### Modes
The SPI protocol supports 4 modes based on clock polarity (CPOL) and phase (CPHA):

| Mode | CPOL | CPHA | Description |
|------|------|------|-------------|
| 0    | 0    | 0    | Clock idles low, data sampled on rising edge |
| 1    | 0    | 1    | Clock idles low, data sampled on falling edge |
| 2    | 1    | 0    | Clock idles high, data sampled on falling edge |
| 3    | 1    | 1    | Clock idles high, data sampled on rising edge |

## Verification Strategy

### Testbench Components

1. **Test Scenarios:**
   - Basic master-slave communication
   - Different SPI modes (0-3)
   - Various data widths
   - Multiple transactions
   - Timing verification

2. **Stimulus Generation:**
   - Randomized data patterns
   - Clock edge alignment verification
   - Mode configuration testing

3. **Prediction & Checking:**
   - Transaction-level verification
   - Bit-level timing checks
   - Data integrity validation

4. **Coverage Metrics:**
   - Clock mode coverage
   - Data width variations
   - Timing edge cases

## Design Architecture

### SPI Master
- **Clock Divisor:** Generates SCLK from system clock
- **Shift Register:** Stores transmit data, receives data
- **FSM:** Controls protocol sequencing
- **Control Logic:** Manages mode, data width, and handshake

### SPI Slave
- **Synchronizer:** Captures SCLK and MOSI with flip-flops
- **Shift Register:** Implements serial-to-parallel conversion
- **Counter:** Tracks bit positions
- **Output Logic:** Manages MISO output timing

## Simulation Setup

### Prerequisites
- Simulation tool (ModelSim, Questa, VCS, Vivado, etc.)
- SystemVerilog support for verification
- Verilog compiler and simulator

### Running Simulations

#### Basic Verilog Testbench:
```bash
vlog SPI_master.v SPI_slave.v SPI_top.v SPI_simple_tb.v
vsim work.SPI_simple_tb
run -all
```

#### SystemVerilog Verification:
```bash
vlog -sv SPI_master.v SPI_slave.v SPI_top.v SPI_top_verification.sv
vsim work.top_module
run -all
```

## Key Verification Scenarios

1. **Single Byte Transfer:** Verify 8-bit data transfer in all SPI modes
2. **Multi-Byte Sequences:** Back-to-back transactions without CS deassertion
3. **Clock Modes:** Verify CPOL and CPHA combinations
4. **Timing Compliance:** Ensure setup/hold time requirements
5. **Edge Cases:** Minimum/maximum clock frequencies, data width variations
6. **Synchronization:** Proper clock domain crossing and CDC (Clock Domain Crossing)

## Implementation Notes

### Clock Frequency Calculation
For a system clock of frequency `f_sys` and desired SPI clock `f_spi`:
```
Clock Divisor = f_sys / (2 * f_spi)
```

### Data Sampling
- Master samples slave output on the opposite clock edge than slave drives it
- This ensures sufficient setup and hold time margins

### Slave Synchronization
- Input signals are synchronized to the system clock using flip-flop chains
- Prevents metastability issues in the slave domain

## Protocol Compliance

This implementation follows standard SPI protocol specifications:
- Meets timing requirements for clock-to-data and chip-select timing
- Supports standard SPI modes (0-3)
- Implements proper CS (Chip Select) assertion/deassertion
- Full-duplex operation capability

## Learning Outcomes

By studying this project, you will learn:

- SPI protocol fundamentals and operation
- Clock domain crossing and synchronization techniques
- Shift register design and usage
- Finite State Machine (FSM) implementation
- Testbench development in SystemVerilog
- Timing verification and constraint checking
- Master-slave communication protocol design
- Synchronous vs. asynchronous signal handling

## Testing Recommendations

1. Start with basic 8-bit transfers in SPI Mode 0
2. Verify correct data appears on MISO with proper timing
3. Test clock polarity and phase variations
4. Add stress tests with back-to-back transactions
5. Verify behavior under different clock frequencies
6. Check CS signal timing relative to clock edges

## File Statistics

- **Verilog:** 71.7%
- **SystemVerilog:** 28.3%
- **Total Commits:** 9

## Applications

- Microcontroller-to-peripheral communication
- Flash memory programming
- Sensor data acquisition
- Display interfaces
- Audio codec communication
- Embedded system design

## References

- [Wikipedia: Serial Peripheral Interface](https://en.wikipedia.org/wiki/Serial_Peripheral_Interface)
- [Motorola SPI Specification](https://www.nxp.com/files-static/application_notes/an10541.pdf)
- SystemVerilog Language Reference Manual
- [Altera: Introduction to SPI Protocol](https://altera.oc.instructure.com/courses/1173/pages/serial-peripheral-interface-spi)

## Future Enhancements

- Multi-slave support with independent CS lines
- Configurable data width (not just 8-bit)
- DMA (Direct Memory Access) integration
- Error detection/correction mechanisms
- Performance optimizations for higher frequencies
- Quad SPI (QSPI) variant support

## License

MIT License

## Author

Gagandeep-25

---

**Note:** This project is designed for educational purposes to understand SPI protocol implementation and verification methodologies in digital design.
